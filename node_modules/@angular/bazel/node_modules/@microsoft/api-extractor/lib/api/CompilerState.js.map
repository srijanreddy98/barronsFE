{"version":3,"file":"CompilerState.js","sourceRoot":"","sources":["../../src/api/CompilerState.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as ts from 'typescript';\r\nimport colors = require('colors');\r\n\r\nimport {\r\n  JsonFile,\r\n  FileSystem\r\n} from '@microsoft/node-core-library';\r\n\r\nimport { ExtractorConfig } from './ExtractorConfig';\r\nimport { IExtractorInvokeOptions } from './Extractor';\r\nimport { TypeScriptMessageFormatter } from '../analyzer/TypeScriptMessageFormatter';\r\n\r\n/**\r\n * Options for {@link CompilerState.create}\r\n * @public\r\n */\r\nexport interface ICompilerStateCreateOptions {\r\n  /** {@inheritDoc IExtractorInvokeOptions.typescriptCompilerFolder} */\r\n  typescriptCompilerFolder?: string;\r\n\r\n  /**\r\n   * Additional .d.ts files to include in the analysis.\r\n   */\r\n  additionalEntryPoints?: string[];\r\n}\r\n\r\n/**\r\n * This class represents the TypeScript compiler state.  This allows an optimization where multiple invocations\r\n * of API Extractor can reuse the same TypeScript compiler analysis.\r\n *\r\n * @public\r\n */\r\nexport class CompilerState {\r\n  /**\r\n   * The TypeScript compiler's `Program` object, which represents a complete scope of analysis.\r\n   */\r\n  public readonly program: ts.Program;\r\n\r\n  private constructor(properties: CompilerState) {\r\n    this.program = properties.program;\r\n  }\r\n\r\n  /**\r\n   * Create a compiler state for use with the specified `IExtractorInvokeOptions`.\r\n   */\r\n  public static create(extractorConfig: ExtractorConfig, options?: ICompilerStateCreateOptions): CompilerState {\r\n\r\n    let tsconfig: {} | undefined = extractorConfig.overrideTsconfig;\r\n    let configBasePath: string = extractorConfig.projectFolder;\r\n    if (!tsconfig) {\r\n      // If it wasn't overridden, then load it from disk\r\n      tsconfig = JsonFile.load(extractorConfig.tsconfigFilePath);\r\n      configBasePath = path.resolve(path.dirname(extractorConfig.tsconfigFilePath));\r\n    }\r\n\r\n    const commandLine: ts.ParsedCommandLine = ts.parseJsonConfigFileContent(\r\n      tsconfig,\r\n      ts.sys,\r\n      configBasePath\r\n    );\r\n\r\n    if (!commandLine.options.skipLibCheck && extractorConfig.skipLibCheck) {\r\n      commandLine.options.skipLibCheck = true;\r\n      console.log(colors.cyan(\r\n        'API Extractor was invoked with skipLibCheck. This is not recommended and may cause ' +\r\n        'incorrect type analysis.'\r\n      ));\r\n    }\r\n\r\n    CompilerState._updateCommandLineForTypescriptPackage(commandLine, options);\r\n\r\n    const inputFilePaths: string[] = commandLine.fileNames.concat(extractorConfig.mainEntryPointFilePath);\r\n    if (options && options.additionalEntryPoints) {\r\n      inputFilePaths.push(...options.additionalEntryPoints);\r\n    }\r\n\r\n    // Append the entry points and remove any non-declaration files from the list\r\n    const analysisFilePaths: string[] = CompilerState._generateFilePathsForAnalysis(inputFilePaths);\r\n\r\n    const program: ts.Program = ts.createProgram(analysisFilePaths, commandLine.options);\r\n\r\n    if (commandLine.errors.length > 0) {\r\n      const errorText: string = TypeScriptMessageFormatter.format(commandLine.errors[0].messageText);\r\n      throw new Error(`Error parsing tsconfig.json content: ${errorText}`);\r\n    }\r\n\r\n    return new CompilerState({\r\n      program\r\n    });\r\n  }\r\n\r\n /**\r\n   * Given a list of absolute file paths, return a list containing only the declaration\r\n   * files.  Duplicates are also eliminated.\r\n   *\r\n   * @remarks\r\n   * The tsconfig.json settings specify the compiler's input (a set of *.ts source files,\r\n   * plus some *.d.ts declaration files used for legacy typings).  However API Extractor\r\n   * analyzes the compiler's output (a set of *.d.ts entry point files, plus any legacy\r\n   * typings).  This requires API Extractor to generate a special file list when it invokes\r\n   * the compiler.\r\n   *\r\n   * Duplicates are removed so that entry points can be appended without worrying whether they\r\n   * may already appear in the tsconfig.json file list.\r\n   */\r\n  private static _generateFilePathsForAnalysis(inputFilePaths: string[]): string[] {\r\n    const analysisFilePaths: string[] = [];\r\n\r\n    const seenFiles: Set<string> = new Set<string>();\r\n\r\n    for (const inputFilePath of inputFilePaths) {\r\n      const inputFileToUpper: string = inputFilePath.toUpperCase();\r\n      if (!seenFiles.has(inputFileToUpper)) {\r\n        seenFiles.add(inputFileToUpper);\r\n\r\n        if (!path.isAbsolute(inputFilePath)) {\r\n          throw new Error('Input file is not an absolute path: ' + inputFilePath);\r\n        }\r\n\r\n        if (ExtractorConfig.hasDtsFileExtension(inputFilePath)) {\r\n          analysisFilePaths.push(inputFilePath);\r\n        }\r\n      }\r\n    }\r\n\r\n    return analysisFilePaths;\r\n  }\r\n\r\n  /**\r\n   * Update the parsed command line to use paths from the specified TS compiler folder, if\r\n   * a TS compiler folder is specified.\r\n   */\r\n  private static _updateCommandLineForTypescriptPackage(\r\n    commandLine: ts.ParsedCommandLine,\r\n    options?: IExtractorInvokeOptions\r\n  ): void {\r\n    const DEFAULT_BUILTIN_LIBRARY: string = 'lib.d.ts';\r\n    const OTHER_BUILTIN_LIBRARIES: string[] = ['lib.es5.d.ts', 'lib.es6.d.ts'];\r\n\r\n    if (options && options.typescriptCompilerFolder) {\r\n      commandLine.options.noLib = true;\r\n      const compilerLibFolder: string = path.join(options.typescriptCompilerFolder, 'lib');\r\n\r\n      let foundBaseLib: boolean = false;\r\n      const filesToAdd: string[] = [];\r\n      for (const libFilename of commandLine.options.lib || []) {\r\n        if (libFilename === DEFAULT_BUILTIN_LIBRARY) {\r\n          // Ignore the default lib - it'll get added later\r\n          continue;\r\n        }\r\n\r\n        if (OTHER_BUILTIN_LIBRARIES.indexOf(libFilename) !== -1) {\r\n          foundBaseLib = true;\r\n        }\r\n\r\n        const libPath: string = path.join(compilerLibFolder, libFilename);\r\n        if (!FileSystem.exists(libPath)) {\r\n          throw new Error(`lib ${libFilename} does not exist in the compiler specified in typescriptLibPackage`);\r\n        }\r\n\r\n        filesToAdd.push(libPath);\r\n      }\r\n\r\n      if (!foundBaseLib) {\r\n        // If we didn't find another version of the base lib library, include the default\r\n        filesToAdd.push(path.join(compilerLibFolder, 'lib.d.ts'));\r\n      }\r\n\r\n      if (!commandLine.fileNames) {\r\n        commandLine.fileNames = [];\r\n      }\r\n\r\n      commandLine.fileNames.push(...filesToAdd);\r\n\r\n      commandLine.options.lib = undefined;\r\n    }\r\n  }\r\n\r\n}\r\n"]}